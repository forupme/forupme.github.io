var tipuesearch = {"pages": [{'title': 'About', 'text': '這裡是\xa0ENG 工程網站: \n 本網站 UR:  https://eng.nfu.edu.tw \xa0 \n 本網站倉儲:  https://github.com/forupme/forupme.github.io \n', 'tags': '', 'url': 'About.html'}, {'title': 'MISC', 'text': 'Fossil SCM \n 網際伺服器: \n Windows: fossil server C:\\pj2022\\repo\\pj2022.fossil --port 9000 --https \n Ubuntu: fossil http /home/pj2022/repository/pj2022.fossil --https --nojail \n fossiloauth \n config.py \n 針對單一倉儲檔案 fossiloauth 中 config.py 設定:\n\nimport authomatic\nfrom authomatic.providers import oauth2\n\n# read client_id and client_secret from safe place other than put into script\nkeyFile = open(\'./../pme_eng_secret.txt\', \'r\')\nwith open(\'./../pme_eng_secret.txt\', \'r\') as f:\n    key = f.read().splitlines()\n\nCONFIG = {\n        \'google\': {\n            \'class_\': oauth2.Google,\n            \'consumer_key\': key[0],\n            \'consumer_secret\': key[1],\n            \'scope\': oauth2.Google.user_info_scope\n        }\n    }\n\ndomain_name = "pme.eng.nfu.edu.tw"\ndefault_repo = "pme"\nrepo_caps = "bfjk234C"\n# for Windows \nrepo_path = "c:/pj2022/repo/"\n# for Ubuntu\n#repo_path = "/home/wcm2021/repository/"\nfossil_port = "443"\nflask_port = "8443"\nuwsgi = True\n\n# derived\ndefault_repo_path = repo_path+default_repo+".fossil"\nflask_url = "https://"+domain_name+":"+flask_port\nflask_forum = "https://"+domain_name+":"+flask_port+"/forum"\n# for multiple repository\n#login_url = "https://"+domain_name+":"+fossil_port+"/"+default_repo+"/login"\n# for single repository\nlogin_url = "https://"+domain_name+":"+fossil_port+"/login"\n# for multiple repository\n#forum_url = "https://"+domain_name+":"+fossil_port+"/"+default_repo+"/forum"\n# for single repository\nforum_url = "https://"+domain_name+":"+fossil_port+"/forum"\nCALLBACK_URL = flask_forum\n \n setup \n Authorised JavaScript origins \n URIs: \n https://pme.eng.nfu.edu.tw:8443 \n Authorised redirect URIs \n https://pme.eng.nfu.edu.tw:8443/login/google/ \n', 'tags': '', 'url': 'MISC.html'}, {'title': 'GW', 'text': 'Google Workspace 應用: \n https://edu.google.com/intl/ALL_tw/workspace-for-education/editions/overview/ \xa0 \n 使用 Python + Flask 建立一個網頁介面，讓管理員透過網頁表單自動在 Google Workspace（前 G Suite）中建立新的 email address（即新增用戶）。 必備條件: 1. Google Workspace 管理員權限：你必須擁有管理員帳號才能新增使用者。 2. Google Cloud Platform 專案：你需要在 GCP 建立一個專案並啟用 [Admin SDK API](https://console.developers.google.com/apis/library/admin.googleapis.com)。 3. 建立服務帳戶（Service Account）並授權 Domain-wide Delegation：這樣 Flask 應用就能以管理員身分進行操作。 4. 下載服務帳戶金鑰（JSON）：Flask 會用這個來驗證。 5. 設定 Google Workspace 的管理員 Email：Flask 會用於 impersonate。 安裝模組: \n pip install flask google-api-python-client google-auth google-auth-oauthlib google-auth-httplib2 \n 範例程式: \n from flask import Flask, request, render_template_string\nfrom google.oauth2 import service_account\nfrom googleapiclient.discovery import build\n\napp = Flask(__name__)\n\n# 服務帳戶金鑰路徑\nSERVICE_ACCOUNT_FILE = \'path/to/your/service-account.json\'\n# 管理員 email\nADMIN_EMAIL = \'admin@yourdomain.com\'\n\n@app.route(\'/\', methods=[\'GET\', \'POST\'])\ndef index():\n    msg = \'\'\n    if request.method == \'POST\':\n        user_email = request.form[\'email\']\n        password = request.form[\'password\']\n        first_name = request.form[\'first_name\']\n        last_name = request.form[\'last_name\']\n        # 建立新使用者\n        result = create_google_user(user_email, password, first_name, last_name)\n        msg = \'帳號建立成功\' if result else \'建立失敗\'\n    return render_template_string("""\n        <form method="post">\n            Email: <input name="email"><br>\n            密碼: <input name="password"><br>\n            名: <input name="first_name"><br>\n            姓: <input name="last_name"><br>\n            <button type="submit">建立</button>\n        </form>\n        <p>{{ msg }}</p>\n    """, msg=msg)\n\ndef create_google_user(email, password, first_name, last_name):\n    SCOPES = [\'https://www.googleapis.com/auth/admin.directory.user\']\n    creds = service_account.Credentials.from_service_account_file(\n        SERVICE_ACCOUNT_FILE, scopes=SCOPES)\n    delegated_creds = creds.with_subject(ADMIN_EMAIL)\n    service = build(\'admin\', \'directory_v1\', credentials=delegated_creds)\n    user_info = {\n        "primaryEmail": email,\n        "password": password,\n        "name": {\n            "givenName": first_name,\n            "familyName": last_name\n        }\n    }\n    try:\n        service.users().insert(body=user_info).execute()\n        return True\n    except Exception as e:\n        print(e)\n        return False\n\nif __name__ == \'__main__\':\n    app.run(debug=True) \n 注意事項: 1. 服務帳戶要開啟「網域範圍授權」（Domain-wide Delegation），管理員要在 Google Workspace 控制台授權該服務帳戶操作指定的範圍。 3. 密碼建議強度：可以加強密碼生成與驗證。 4. 部署建議：請勿將服務帳戶金鑰暴露於公開網路。 5. 安全性：建議加入認證機制，避免未授權使用。 \n', 'tags': '', 'url': 'GW.html'}, {'title': 'Reeborg', 'text': 'https://eng.nfu.edu.tw/reeborg \xa0 \n 假如利用相對路徑呼叫 URL 變數值: \n 以下為單數行面向北收成後，雙數行向南收成。 \n https://eng.nfu.edu.tw/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1.py \xa0 \n 以下則為東西方向收成。 \n https://eng.nfu.edu.tw/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_east_west.py\xa0 \xa0 \n', 'tags': '', 'url': 'Reeborg.html'}, {'title': 'NX2312', 'text': 'NXOpen 範例:  https://github.com/mdecycu/nxopen \xa0 \n 截至 2024 年 6 月，Siemens NX（Siemens Digital Industries Software 的旗艦 CAD/CAM/CAE 解決方案）尚未正式宣布其產品將「全部」轉為 SaaS（Software as a Service，雲端服務）模式。以下是現況與未來趨勢的分析： \n 現況說明 \n \n 混合授權模式 ：目前 Siemens NX 提供傳統本地端安裝（on-premise）、浮動授權與雲端授權（Cloud Connected Licensing）等多種方式。 \n 雲端與 SaaS 進展 ：\n \n Siemens 近年積極推動其 Xcelerator 雲端平台，並陸續推出 Teamcenter X、NX X 等 SaaS 產品線。 \n Siemens NX 已能透過雲端桌面、虛擬化等方式運作，但 NX 的 SaaS 版本（NX X）目前仍屬於部分功能雲端化，並非完全替代本地端。 \n Siemens 官方強調會「持續支援混合部署」（hybrid deployment），以配合不同行業、地區的 IT 政策與資料安全需求。 \n \n \n \n 未來趨勢（預測） \n \n 逐步推進 SaaS ：全球 CAD/CAM 巨頭（如 Autodesk, PTC, Dassault Systèmes）都在加速 SaaS 轉型，Siemens 也不例外，但考量現有大型工業客戶的需求，完全移除本地端安裝在短期內機率不高。 \n 靈活選擇 ：預計未來 5-10 年內，Siemens NX 會維持本地端與 SaaS 雙軌並行，讓客戶根據需求選擇。 \n SaaS 比重提升 ：隨著雲端安全與效能提升，以及企業 IT 策略轉型，SaaS 模式的比重會逐年提高。 \n \n 後續議題: \n NXOpen 的程式架構, 一旦轉為 Saas 後, 請說明其後續應用模式大致如何? \n 將  NXOpen  的程式架構轉為  SaaS（Software as a Service）  模式後，會對其 開發方式、部署方式、客戶使用習慣、整合介面與授權模式 產生重大變化。以下是轉為 SaaS 模式後的  後續應用模式解析 ： \n \n 🔧 一、NXOpen 是什麼？ \n NXOpen  是 Siemens NX 提供的一套 API（支援 C++, C#, VB.NET, Java、Python），讓用戶能夠對 NX CAD/CAM/CAE 系統進行客製化與二次開發。 \n \n ☁️ 二、轉為 SaaS 模式後的主要應用變化： \n 1.  開發與部署模式轉變：從本機執行變為雲端整合 \n \n \n \n 項目 \n 傳統 NXOpen \n SaaS 化後 \n \n \n \n \n 執行位置 \n 本機 NX 軟體上執行 plug-in 或 API 呼叫 \n 透過 Web API / 雲端平台觸發 \n \n \n 程式部署 \n 安裝 DLL 或 script 到本地端 \n 部署於雲端容器 / 微服務架構 \n \n \n 整合方式 \n 使用本機 NX COM 或 Open API \n 使用 RESTful API / GraphQL / Webhook \n \n \n \n ✅ SaaS 模式下： \n \n \n NX 本體可能以虛擬桌面、Web NX（若 Siemens 支援）或 Hybrid WebApp 的方式提供 \n \n \n 開發者將客製功能部署在雲端，可藉由 HTTP API 被用戶端（甚至非 NX 應用）呼叫 \n \n \n \n 2.  模組化與微服務化 \n \n \n 傳統 NXOpen 開發的是 plug-in 或宏指令，SaaS 模式則可拆成「功能模組微服務」： \n \n \n 例如：「自動建模」、「幾何驗證」、「刀具路徑最佳化」等功能做為 API 提供 \n \n \n 每個功能可被其他內部/外部系統串接（如 PLM、MES、BOM 系統） \n \n \n \n \n \n 3.  資料傳輸與儲存改變 \n \n \n 使用者的 3D 模型、幾何參數可能上傳至雲端伺服器 \n \n \n 可支援版本控管、多人協同操作、異地編輯等功能 \n \n \n 與 Teamcenter、Cloud PLM 無縫整合 \n \n \n \n 4.  使用者互動模式 \n \n \n \n 模式 \n 傳統 \n SaaS \n \n \n \n \n 使用界面 \n 本地 NX GUI 操作 \n Web-based NX、API 呼叫、輕量介面（如瀏覽器） \n \n \n 客製 UI \n 插件型窗口、Form \n Web App、Dashboard、雲端協同平台 \n \n \n 使用者 \n 單一工程師使用 \n 多人協同（設計、製造、客戶）即時互動 \n \n \n \n \n 5.  授權與訂閱模式 \n \n \n 傳統 NX 授權基於安裝主機的 License \n \n \n SaaS 模式改為  基於用量（Usage-based）  或  訂閱（Subscription） \n \n \n 按 API 呼叫數量計費 \n \n \n 按帳戶使用時間、功能模組區分計費 \n \n \n \n \n \n 6.  後續可能的應用場景 \n \n \n ✅ 自動化設計平台（例如 Web UI 輸入參數 → 雲端 NX 建模 → 下載 STEP） \n \n \n ✅ 多人協同設計（像 Google Docs 那樣的 CAD 協作） \n \n \n ✅ 與 AI 系統整合（AI 生成設計草圖，SaaS API 執行建模驗證） \n \n \n ✅ 和製造雲端 MES 或供應鏈平台整合，做自動流程串接 \n \n \n \n 🧭 總結 \n 轉為 SaaS 模式後，NXOpen 不再只是「開發者在本地 NX 上開發插件」，而是變成 可被任意雲端平台呼叫的 CAD 智能功能服務（Engineering-as-a-Service） 。這樣的模式有利於企業： \n \n \n 簡化部署與維運 \n \n \n 更快導入自動化流程 \n \n \n 支援全球團隊協同作業 \n \n \n 更靈活的成本控制與計費 \n \n \n \n 延伸議題: \n 之後的機械設計工程師若要使用 NXOpen 是否必須具備更多的 Web based programming 技術? \n 是的， 未來的機械設計工程師若要在 NXOpen 的 SaaS 環境中開發或應用客製化功能，勢必需要具備更多 Web-based programming 技術與知識 ，原因如下： \n \n ✅ 為什麼需要 Web-based Programming 技術？ \n 1.  開發介面從本地 API 轉向雲端 API \n \n \n 過去：使用 C++ / C# 呼叫 NXOpen 的本地 DLL \n \n \n 未來：透過 RESTful API、GraphQL 等 Web 介面來存取 NX 雲端功能 \n \n \n ➡️ 工程師需要了解： \n \n \n HTTP 請求（GET/POST） \n \n \n JSON 資料格式 \n \n \n API 認證（Token, OAuth） \n \n \n \n 2.  前端互動越來越重要 \n 若未來使用 NX Web 平台（或其整合式 UI），工程師可能要： \n \n \n 設計客製化的網頁表單 \n \n \n 用 JavaScript 與 NX API 互動 \n \n \n ➡️ 建議學會： \n \n \n JavaScript / TypeScript \n \n \n React / Vue 等前端框架 \n \n \n HTML5 / CSS3 基礎 \n \n \n \n 3.  微服務與自動化流程 \n 許多 SaaS 架構會將功能模組化為微服務，例如： \n \n \n 自動建模服務 \n \n \n 自動生成工程圖服務 \n \n \n 這些都可能透過 Webhook 或 API 觸發。機械設計工程師需要能： \n \n \n 建立 pipeline（例如 Python 腳本串接 Web API） \n \n \n 撰寫跨平台的資料流程（如將 NX 資料傳給 PLM 或 CAM 系統） \n \n \n ➡️ 工具建議： \n \n \n Python（結合 Flask / FastAPI 做簡易服務） \n \n \n Git / CI/CD 概念 \n \n \n 基礎的 Docker 容器知識 \n \n \n \n 🧠 所以未來的「NXOpen 工程師」會長這樣： \n \n \n \n 能力領域 \n 需懂技術 \n 原因 \n \n \n \n \n 機械設計知識 \n Solid modeling, PMI, CAE 概念 \n 工程本質還是設計 \n \n \n 雲端 API 串接 \n RESTful API, JSON \n 呼叫 SaaS 平台功能 \n \n \n Web UI 開發（選配） \n JavaScript, React \n 若需設計互動界面 \n \n \n 資料流與整合 \n Python, Webhook, Git \n 自動化與系統串接需求 \n \n \n 安全與授權 \n OAuth, JWT \n Web API 呼叫需要身份驗證 \n \n \n \n \n 🎯 小結 \n 未來使用 NXOpen 的工程師，尤其若參與企業數位轉型或雲端化開發專案，勢必要具備  Web-based programming 的基礎能力 。這並不代表要成為全職 Web 工程師，但需要： \n \n \n 能看懂 API 文件 \n \n \n 能用 Python / JavaScript 寫簡單整合程式 \n \n \n 理解前後端如何協作 \n \n \n \n 當前機械工程師面對的是一個快速數位化的產業環境，尤其在 CAD/CAE 平台（如 NX）逐步 SaaS 化、自動化與智能化的趨勢下， 具備跨界的程式設計與系統整合能力 變得非常重要。以下是我為「機械背景工程師」設計的  分階段、實務導向的學習路線圖 ，強調從無基礎到具備 SaaS 架構開發與應用能力。 \n \n 🎯 學習目標總覽 \n \n \n \n 階段 \n 能力核心 \n 目的 \n \n \n \n \n 入門階段 \n 基本程式能力 \n 能看懂、撰寫簡單自動化腳本 \n \n \n 成長階段 \n API 串接與資料處理 \n 能與 NX SaaS 功能對接 \n \n \n 進階階段 \n Web 應用與自動化架構 \n 能開發雲端工具或整合流程 \n \n \n 專業階段 \n 微服務與 DevOps 概念 \n 能部署工程服務並參與企業級專案 \n \n \n \n \n 🧩【第一階段：程式設計入門】🔰 \n \n 適合從沒學過程式的工程師 \n \n 🔹 學習內容 \n \n \n Python 基礎語法（變數、條件、迴圈） \n \n \n 函式與模組概念 \n \n \n 檔案處理（CSV, JSON） \n \n \n 程式邏輯與問題拆解 \n \n \n ✅ 建議工具/平台 \n \n \n Python（建議選擇） \n \n \n VS Code \n \n \n 線上學習：Codecademy、Coursera（Python for Everybody） \n \n \n 📌 實作範例 \n \n \n 寫一支自動命名圖檔的工具 \n \n \n 解析 CSV 製造清單，自動計算總成本 \n \n \n \n 🧩【第二階段：NX API 與 Web 串接】🔗 \n \n 為連接 SaaS NX 系統做好準備 \n \n 🔹 學習內容 \n \n \n NXOpen（C# or Python）API 概念與結構 \n \n \n RESTful API 基礎（GET / POST / Header） \n \n \n JSON 結構與資料轉換 \n \n \n 呼叫 NX SaaS 的 API（假設已公開） \n \n \n ✅ 建議工具 \n \n \n Postman（測試 API） \n \n \n Python requests 套件 \n \n \n 熟悉 NX 本地端 API（必要時） \n \n \n 📌 實作範例 \n \n \n 使用 Python 呼叫 NX 雲端 API，自動建立 3D 模型 \n \n \n 把本地 NX 生成的資料上傳到 Web 系統 \n \n \n \n 🧩【第三階段：Web 前端與後端應用】🌐 \n \n 讓你能設計前端輸入畫面，後端處理模型或資料 \n \n 🔹 學習內容 \n \n \n HTML5 / CSS3 / JavaScript 基礎 \n \n \n 使用 React.js 製作互動介面 \n \n \n Python + Flask（或 FastAPI）作為後端 API 伺服器 \n \n \n 網頁如何觸發模型運算或匯出圖檔 \n \n \n ✅ 建議工具 \n \n \n GitHub、VS Code、React + Flask 專案模板 \n \n \n Docker 基礎（可選） \n \n \n 📌 實作範例 \n \n \n 建立一個「線上建模輸入系統」：用戶輸入尺寸 → 後端呼叫 NX SaaS API → 顯示模型預覽 \n \n \n 前端 UI 控制不同模組組合，動態產生 3D 零件 \n \n \n \n 🧩【第四階段：整合與部署工程平台】🚀 \n \n 可參與企業專案，或打造自己的工程應用服務 \n \n 🔹 學習內容 \n \n \n 軟體架構：MVC、API Gateway、資料庫整合 \n \n \n 使用 Git + CI/CD（GitHub Actions） \n \n \n 雲端部署（AWS/GCP/Azure） \n \n \n OAuth / Token 身分驗證 \n \n \n ✅ 工具建議 \n \n \n Docker + Docker Compose \n \n \n GitHub + Netlify / Railway / Vercel \n \n \n Kubernetes（進階） \n \n \n 📌 實作範例 \n \n \n 將工程設計 SaaS 工具部署上雲端，提供 API 給企業內部使用 \n \n \n 整合 NX SaaS + PLM + ERP 的工作流程 \n \n \n \n 📚 推薦資源 \n \n \n \n 類型 \n 資源 \n \n \n \n \n Python 入門 \n Python for Everybody（Coursera） \n \n \n Web 前端 \n freeCodeCamp \n \n \n REST API \n Postman Learn \n \n \n NXOpen \n Siemens 官方文件 + GitHub 上的開源專案 \n \n \n DevOps / 雲端 \n Docker 教學 、 AWS Skill Builder \n \n \n \n \n ✅ 結語與建議 \n 你 不需要成為全職軟體工程師 ，但未來的機械工程師會是： \n \n \n 能開發簡易自動化工具 \n \n \n 會串接 SaaS CAD 平台與企業系統 \n \n \n 理解 Web 技術，能與 IT 部門協作開發 \n \n \n 🌟 最重要的是  從小任務開始實作，逐步構建信心與能力 。 \n \n \n', 'tags': '', 'url': 'NX2312.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n', 'tags': '', 'url': 'Brython.html'}]};